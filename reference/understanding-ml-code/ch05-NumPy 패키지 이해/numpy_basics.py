#
# 프로그램 이름: numpy_basics.py
# 작성자: Bong Ju Kang
# 설명: NumPy의 기본을 예제와 함께 이해하기
#

# 필요한 패키지
import numpy as np

#
# 배열의 생성 및 속성 파악
#
# 리스트를 통하여 1차원 배열의 생성
a = np.array([1, 2, 3, 4])
# print(a)를 하는 역할을 ctrl+enter 키로 값을 확인

a # ctrl+enter 키를 통하여 값을 확인
# array([1, 2, 3, 4])

type(a) # 넘파이 n차원 배열 데이터 형
# numpy.ndarray

a.ndim # 하나의 메서드로써 차원의 크기를 확인
# 1

np.ndim(a) # 하나의 함수로써 차원의 크기를 확인
# 1

a.shape # 메소드 호출을 통한 배열의 크기를 확인
# (4,) # 튜플 형식으로 배열의 크기를 반환함

np.shape(a) # 함수 호출로도 가능

a.dtype # 각 요소의 데이터 형
# dtype('int32')

#
# 배열 연산
#
a = np.array([1,2,3,4])
b = np.array([10,20,30,40])

# 리스트인 경우에 + 연산의 의미
[1,2,3,4] + [10,20,30,40]
# [1, 2, 3, 4, 10, 20, 30, 40]

a + b # 요소 별 덧셈
# array([11, 22, 33, 44])

a - b # 요소 별 뺄셈
# array([ -9, -18, -27, -36])

a * b # 요소 별 곱하기
# array([ 10,  40,  90, 160])

a ** b # 요소 별 제곱 승
# array([          1,     1048576, -1010140999,           0], dtype=int32)

a**2 # 2가 앞의 배열과 요소 별 제곱승 할 수 있도록 자동으로 배열의 크기가 확장됨 (브로드캐스팅)

np.pi
# 3.141592653589793

np.sin(a*np.pi)
# array([ 1.2246468e-16, -2.4492936e-16,  3.6739404e-16, -4.8985872e-16])

np.sqrt(a)
# array([1.        , 1.41421356, 1.73205081, 2.        ])

#
# 배열 요소(element) 값 정하기
#
a = np.array([1,2,3,4])

a[0] # 요소 값 조회하기
# 1

a[0] = 9 # 요소 값 수정하기
a
# array([9, 2, 3, 4])

a[1] = 0.9 # 요소 값에 다른 데이터 형으로 값을 주는 경우
a
# array([9, 0, 3, 4])
# 원래 데이터 형으로 전환하여 수정됨
a.dtype
# dtype('int32')

a.fill(-10) # 모든 값을 하나의 값을 수정하기
a
# array([-10, -10, -10, -10])

#
# 다차원 배열
#
a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
a
# array([[1, 2, 3, 4],
#        [5, 6, 7, 8]])

a.shape # 다차원 배열의 구성 확인
# (2, 4)

a.ndim
# 2

a[0,0]
# 1
a[-1, -1] # 다차원 배열의 마지막 값 조회
# 8

a[0,0] = 100 # 다차원 배열의 값 수정
a
# array([[100,   2,   3,   4],
#        [  5,   6,   7,   8]])

a[-1] # 행 우선이므로 행의 마지막 값 조회
# array([5, 6, 7, 8])

#
# 배열 조각내기(slicing)
#

a = np.arange(1, 10) # 1부터 9까지 수를 생성
a
# array([1, 2, 3, 4, 5, 6, 7, 8, 9])

a[0:3] # 인덱스 값이 0부터 2까지
# array([1, 2, 3])

a[1:-1] # 인덱스 값이 1부터 -1-1=-2까지
# array([2, 3, 4, 5, 6, 7, 8])

a[:] # 생략하는 경우
# array([1, 2, 3, 4, 5, 6, 7, 8, 9])

a[::]
# array([1, 2, 3, 4, 5, 6, 7, 8, 9])

a[::2] # 처음 부터 시작하여 +2만큼 인덱스 증가시켜 마지막까지
# array([1, 3, 5, 7, 9])

b = np.arange(1,17).reshape(4,4) # 다차원 배열 구성 (4x4)
b
# array([[ 1,  2,  3,  4],
#        [ 5,  6,  7,  8],
#        [ 9, 10, 11, 12],
#        [13, 14, 15, 16]])

b[:, 2] # 열의 인덱스가 2인 조각
# array([3, 7, 11, 15])

b[1::2, ::2] # 행의 인덱스가 1부터 시작하여 2만큼 증가, 이러한 조건 하에 열의 인덱스는 +2만큼 증가
# array([[ 5,  7],
#        [13, 15]])

#
# 조각의 요소 값 변경의 효과
#

b = np.arange(1,17).reshape(4,4) # 다차원 배열 구성 (4x4)
b
# array([[ 1,  2,  3,  4],
#        [ 5,  6,  7,  8],
#        [ 9, 10, 11, 12],
#        [13, 14, 15, 16]])
x = b[:, 0] # 하나의 조각
x
# array([ 1,  5,  9, 13])

x[0] = 100 # 조각의 요소 값 변경
x
# array([100,   5,   9,  13])
b # 원래 배열의 값도 변경됨!
# array([[100,   2,   3,   4],
#        [  5,   6,   7,   8],
#        [  9,  10,  11,  12],
#        [ 13,  14,  15,  16]])

#
# 팬시 인덱싱 (fancy indexing)
#
a = np.arange(0,100, 10)
a
# array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])

a[np.array([0, 1, 3])] # 인덱스 값을 배열로 전달
a[[0, 1, 3]] # 인덱스 값을 리스트로 전달해도 됨
# array([ 0, 10, 30])

x = a[[0, 1, 3]]
x[0] =100 # 팬시 인덱싱한 결과에 값을 수정
x
# array([100,  10,  30])
a # 팬시 인덱싱한 결과는 원래 배열에 영향을 주지 않음 (복사하여 처리)
# array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])

bool_mask = np.array([0, 0, 0, 1, 1, 1, 0, 0, 0, 0], dtype=bool)
bool_mask
# array([False, False, False,  True,  True,  True, False, False, False,
#        False])

a[bool_mask] # 불 배열에 의한 팬시 인덱싱
# array([30, 40, 50])

b = np.arange(1, 26).reshape(5,5)
b
# array([[ 1,  2,  3,  4,  5],
#        [ 6,  7,  8,  9, 10],
#        [11, 12, 13, 14, 15],
#        [16, 17, 18, 19, 20],
#        [21, 22, 23, 24, 25]])

b[0:2, [1, 3]] # 조각내기와 팬시 인덱싱의 결합
# array([[2, 4],
#        [7, 9]])

b[[0,1], [2,1]] # (행, 열) 인덱스 값이 각각 (0, 2), (1, 1)인 값을 반환
# array([3, 7])

# 팬시 인덱싱에서 b[:, 1]과 b[:, [1]]의 차이
b[:, 1] # 행 벡터를 반환
# array([ 2,  7, 12, 17, 22])

b[:, [1]] # 행렬을 반환
# array([[ 2],
#        [ 7],
#        [12],
#        [17],
#        [22]])

#
# 배열 생성자
#
a = np.array([1.0, 2, 3, 100]) # 하나라도 실수가 있는 경우
a
# array([  1.,   2.,   3., 100.])
a.dtype
# dtype('float64') # 전체 기본 데이터 형은 실수

a = np.array([1.0, 2, 3, 100], dtype=np.int32) # 데이터 기본 형을 선언하는 경우
a.dtype
# dtype('int32') # 선언된 형으로 정리됨

np.arange(0, 10, 2) # start, stop, step 형식으로 구성됨. 단 stop 보다 작은 값까지만 유효함.
# array([0, 2, 4, 6, 8])

np.arange(1.5, 2.7, 0.3) # 정수가 아닌 경우에는 stop 보다 작은 값이 아닌 경우가 있음
# array([1.5, 1.8, 2.1, 2.4, 2.7])

np.arange(10) # 하나의 값만 있는 경우는 stop 값으로 인식
# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

np.zeros((3,)) # 튜플 형식으로 크기를 입력
# array([0., 0., 0.])

np.ones((3,4))
# array([[1., 1., 1., 1.],
#        [1., 1., 1., 1.],
#        [1., 1., 1., 1.]])

np.linspace(0, 1, 10) # start, stop, n 이며, 시작부터 끝까지 n개로 균등하게 나누는 값을 반환
# array([0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
#        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ])

np.random.RandomState(1234).normal(100, 1, 5) # 평균 100, 표준편차 1인 정규 분포에서 난수 5개 발생
# array([100.47143516,  98.80902431, 101.43270697,  99.6873481 ,
#         99.27941127])

#
# 배열의 추가 (행 또는 열)
#

# 배열의 생성
a = np.arange(10)
b = np.random.RandomState(123).normal(size=10)

# 기존 배열에 새로운 배열 추가: 행 추가
np.r_[a, b]
# array([ 0.        ,  1.        ,  2.        ,  3.        ,  4.        ,
#         5.        ,  6.        ,  7.        ,  8.        ,  9.        ,
#        -1.0856306 ,  0.99734545,  0.2829785 , -1.50629471, -0.57860025,
#         1.65143654, -2.42667924, -0.42891263,  1.26593626, -0.8667404 ])

# 기존 배열에 새로운 배열 추가: 열 추가
np.c_[a, b]
# array([[ 0.        , -1.0856306 ],
#        [ 1.        ,  0.99734545],
#        [ 2.        ,  0.2829785 ],
#        [ 3.        , -1.50629471],
#        [ 4.        , -0.57860025],
#        [ 5.        ,  1.65143654],
#        [ 6.        , -2.42667924],
#        [ 7.        , -0.42891263],
#        [ 8.        ,  1.26593626],
#        [ 9.        , -0.8667404 ]])


#
# 배열의 축과 계산
#
a = np.arange(1, 11).reshape((2, 5))
a
# array([[ 1,  2,  3,  4,  5],
#        [ 6,  7,  8,  9, 10]])

a.sum() # 축을 명시하지 않으면, 전체의 합
# 55

a.sum(axis=0) # 축0을 따라서 합을 구함. 모든 열 별로 합이 나옴
# array([ 7,  9, 11, 13, 15])

a.sum(axis=1) # 축1을 따라서 합을 구함. 모든 행 별로 합이 나옴
# array([15, 40])

a.mean(axis=0) # 열 별 평균
# array([3.5, 4.5, 5.5, 6.5, 7.5])

a.std(axis=0) # 열 별 표준편차
# array([2.5, 2.5, 2.5, 2.5, 2.5])

#
# 배열 방송(broadcasting)
#
a = np.ones((2,4))
b = np.ones((4,))

a + b # 모양이 다름에도 불구하고 방송이 되어 처리가 됨
# array([[2., 2., 2., 2.],
#        [2., 2., 2., 2.]])

# a + b 를 구하기 위한 방송을 하지 않고 처리하는 경우
# 추가로 bbb를 생성하여 처리
bb = b.reshape((1,4))
bb
# array([[1., 1., 1., 1.]])
bbb = bb.repeat(2, axis=0)
bbb
# array([[1., 1., 1., 1.],
#        [1., 1., 1., 1.]])
a + bbb
# array([[2., 2., 2., 2.],
#        [2., 2., 2., 2.]])

a = np.arange(12). reshape((4, 3))
b = np.arange(6).reshape((2,3))
a + b
# ValueError: operands could not be broadcast together with shapes (4,3) (2,3)

b = np.arange(4).reshape((4,1))
a + b
# array([[ 0,  1,  2],
#        [ 4,  5,  6],
#        [ 8,  9, 10],
#        [12, 13, 14]])

b = np.arange(3).reshape((3,))
a + b
# array([[ 0,  2,  4],
#        [ 3,  5,  7],
#        [ 6,  8, 10],
#        [ 9, 11, 13]])

a = np.arange(4).reshape((4,1))
b = np.arange(3).reshape((3,))
a + b
# array([[0, 1, 2],
#        [1, 2, 3],
#        [2, 3, 4],
#        [3, 4, 5]])




